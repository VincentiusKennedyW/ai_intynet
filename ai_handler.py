"""
AI Handler - Full AI-Generated Responses Version
Every response is generated by AI for natural, varied conversation
"""
import os
import json
from typing import Dict, Any, Optional, List
from openai import AsyncOpenAI
from datetime import datetime
import random

client = AsyncOpenAI(api_key=os.getenv("OPENAI_API_KEY", "sk-test-key"))


class AIHandler:
    """Handles AI conversation with full AI-generated responses"""
    
    # Conversation states
    STATE_GREETING = "greeting"
    STATE_COLLECT_CUSTOMER_ID = "collect_customer_id"
    STATE_COLLECT_ADDRESS = "collect_address"
    STATE_COLLECT_ISSUE_TYPE = "collect_issue_type"
    STATE_COLLECT_DESCRIPTION = "collect_description"
    STATE_CONFIRM_DATA = "confirm_data"
    STATE_COMPLETED = "completed"
    
    # Issue types
    ISSUE_TYPES = [
        "Internet mati total",
        "Internet lambat",
        "WiFi bermasalah",
        "Tidak bisa akses website tertentu",
        "Lainnya"
    ]
    
    # Neti's personality
    PERSONALITY = """Kamu adalah Neti, asisten virtual dari Intynet (ISP di Balikpapan).

Personality:
- Ramah, helpful, dan empathetic terhadap customer yang mengalami gangguan
- Bahasa Indonesia casual tapi tetap profesional
- Pakai emoji secukupnya (1-2 per message, jangan berlebihan)
- Responsif terhadap emosi customer (kalau kesal â†’ lebih empathetic)
- Variasi sapaan: "Halo!", "Hai kak!", "Halo!", "Hai!", dll
- Bisa pakai "saya" atau "aku" (variasi natural)
- Sesekali pakai filler words: "Baik", "Oke", "Siap", "Noted", "Oke sip"

CRITICAL RULES:
- Response HARUS SINGKAT: max 2-3 kalimat
- LANGSUNG ke inti, NO bertele-tele
- Jangan terlalu formal atau kaku
- Natural seperti chat CS manusia biasa
- Jangan gunakan format numbering (1., 2., 3.) kecuali untuk pilihan issue type"""
    
    def __init__(self):
        self.model = "gpt-4o-mini"
        self.conversation_history: Dict[str, List[Dict]] = {}
    
    def _get_conversation_history(self, customer_id: str) -> List[Dict]:
        """Get conversation history for maintaining context"""
        if customer_id not in self.conversation_history:
            self.conversation_history[customer_id] = []
        return self.conversation_history[customer_id]
    
    def _add_to_history(self, customer_id: str, role: str, content: str):
        """Add message to history"""
        history = self._get_conversation_history(customer_id)
        history.append({"role": role, "content": content})
        
        # Keep last 10 messages only
        if len(history) > 10:
            self.conversation_history[customer_id] = history[-10:]
    
    async def _generate_ai_response(
        self,
        customer_id: str,
        instruction: str,
        user_message: str,
        collected_data: Dict[str, Any]
    ) -> str:
        """Generate AI response with full context"""
        
        # Build context
        context_parts = [self.PERSONALITY, "", instruction]
        
        # Add collected data
        if collected_data:
            context_parts.append("\nData terkumpul:")
            for key, value in collected_data.items():
                if key not in ["phone"]:  # Don't show internal data
                    context_parts.append(f"- {key}: {value}")
        
        system_prompt = "\n".join(context_parts)
        
        # Get conversation history
        history = self._get_conversation_history(customer_id)
        
        # Build messages
        messages = [
            {"role": "system", "content": system_prompt}
        ] + history + [
            {"role": "user", "content": user_message}
        ]
        
        try:
            response = await client.chat.completions.create(
                model=self.model,
                messages=messages,
                temperature=0.8,  # Higher for creativity
                max_tokens=200
            )
            
            ai_response = response.choices[0].message.content.strip()
            
            # Add to history
            self._add_to_history(customer_id, "user", user_message)
            self._add_to_history(customer_id, "assistant", ai_response)
            
            return ai_response
        
        except Exception as e:
            print(f"AI Response Error: {e}")
            return "Maaf, ada kendala sistem sebentar. Bisa coba lagi?"
    
    async def process_message(
        self,
        customer_id: str,
        customer_name: str,
        message: str,
        session: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Process message and route to appropriate handler"""
        
        current_state = session.get("state", self.STATE_GREETING)
        collected_data = session.get("collected_data", {})
        
        # Store customer info
        if customer_name and "customer_name" not in collected_data:
            collected_data["customer_name"] = customer_name
        if customer_id and "phone" not in collected_data:
            collected_data["phone"] = customer_id
        
        # Route to handler
        if current_state == self.STATE_GREETING:
            return await self._handle_greeting(customer_id, message, collected_data)
        elif current_state == self.STATE_COLLECT_CUSTOMER_ID:
            return await self._handle_customer_id(customer_id, message, collected_data)
        elif current_state == self.STATE_COLLECT_ADDRESS:
            return await self._handle_address(customer_id, message, collected_data)
        elif current_state == self.STATE_COLLECT_ISSUE_TYPE:
            return await self._handle_issue_type(customer_id, message, collected_data)
        elif current_state == self.STATE_COLLECT_DESCRIPTION:
            return await self._handle_description(customer_id, message, collected_data)
        elif current_state == self.STATE_CONFIRM_DATA:
            return await self._handle_confirmation(customer_id, message, collected_data)
        else:
            return await self._handle_greeting(customer_id, message, {})
    
    async def _handle_greeting(
        self,
        customer_id: str,
        message: str,
        collected_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Greeting + issue detection"""
        
        # Detect if user mentioned issue
        detection_prompt = f"""Analisis: "{message}"

Apakah ada keluhan/masalah internet? JSON only:
{{"has_issue": true/false, "issue_summary": "singkat atau null"}}"""
        
        try:
            resp = await client.chat.completions.create(
                model=self.model,
                messages=[{"role": "user", "content": detection_prompt}],
                temperature=0.3,
                response_format={"type": "json_object"}
            )
            
            result = json.loads(resp.choices[0].message.content.strip())
            
            if result.get("has_issue"):
                collected_data["initial_complaint"] = result["issue_summary"]
                
                instruction = f"""User lapor masalah: {result['issue_summary']}

Task: Sapa, acknowledge masalahnya dengan empathy, bilang akan bantu buat laporan, minta nomor pelanggan (format: C650AD).
Max 3 kalimat."""
                
                reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
                next_state = self.STATE_COLLECT_CUSTOMER_ID
            else:
                instruction = """User menyapa. Task: Sapa ramah, perkenalkan sebagai Neti dari Intynet, tanya ada yang bisa dibantu. Max 2 kalimat."""
                
                reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
                next_state = self.STATE_GREETING
        
        except Exception as e:
            print(f"Greeting error: {e}")
            instruction = "Sapa user sebagai Neti dari Intynet, tanya ada yang bisa dibantu."
            reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
            next_state = self.STATE_COLLECT_CUSTOMER_ID
        
        return {
            "reply": reply,
            "session": {"state": next_state, "collected_data": collected_data}
        }
    
    async def _handle_customer_id(
        self,
        customer_id: str,
        message: str,
        collected_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Extract customer ID"""
        
        prompt = f"""Extract nomor pelanggan dari: "{message}"
Format: huruf+angka (C650AD, A123BC)
JSON only: {{"customer_id": "ID atau null", "confidence": "high/medium/low"}}"""
        
        try:
            resp = await client.chat.completions.create(
                model=self.model,
                messages=[{"role": "user", "content": prompt}],
                temperature=0.1,
                response_format={"type": "json_object"}
            )
            
            result = json.loads(resp.choices[0].message.content.strip())
            
            if result.get("customer_id") and result["confidence"] in ["high", "medium"]:
                collected_data["customer_id"] = result["customer_id"]
                
                instruction = f"""User kasih nomor pelanggan: {result['customer_id']}
Task: Confirm dengan âœ…, lalu minta alamat lengkap lokasi gangguan. Max 2 kalimat."""
                
                reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
                next_state = self.STATE_COLLECT_ADDRESS
            else:
                instruction = "Gagal kenali nomor pelanggan. Minta ulangi dengan ramah, kasih contoh (C650AD). Max 2 kalimat."
                reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
                next_state = self.STATE_COLLECT_CUSTOMER_ID
        
        except Exception as e:
            print(f"Customer ID error: {e}")
            import re
            match = re.search(r'[A-Z]\d{3,}[A-Z]*', message.upper())
            if match:
                collected_data["customer_id"] = match.group(0)
                instruction = f"User kasih nomor {match.group(0)}. Confirm dan minta alamat."
                reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
                next_state = self.STATE_COLLECT_ADDRESS
            else:
                instruction = "Gagal kenali nomor. Minta ulangi."
                reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
                next_state = self.STATE_COLLECT_CUSTOMER_ID
        
        return {
            "reply": reply,
            "session": {"state": next_state, "collected_data": collected_data}
        }
    
    async def _handle_address(
        self,
        customer_id: str,
        message: str,
        collected_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Collect address"""
        
        if len(message.strip()) < 10:
            instruction = "Alamat terlalu singkat. Minta alamat lengkap dengan contoh (Jl. Merdeka No. 123, RT/RW). Max 2 kalimat."
            reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
            next_state = self.STATE_COLLECT_ADDRESS
        else:
            collected_data["address"] = message.strip()
            
            # Show issue type options
            issue_list = "\n".join([f"{i+1}. {t}" for i, t in enumerate(self.ISSUE_TYPES)])
            
            instruction = f"""Alamat: {message.strip()} sudah dicatat âœ…

Task: Sekarang minta pilih jenis gangguan dari list berikut:
{issue_list}

Bilang bisa balas nomor atau ketik jenis gangguannya. Max 3 kalimat."""
            
            reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
            next_state = self.STATE_COLLECT_ISSUE_TYPE
        
        return {
            "reply": reply,
            "session": {"state": next_state, "collected_data": collected_data}
        }
    
    async def _handle_issue_type(
        self,
        customer_id: str,
        message: str,
        collected_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Extract issue type"""
        
        issue_type = None
        
        # Check if number
        if message.strip().isdigit():
            idx = int(message.strip()) - 1
            if 0 <= idx < len(self.ISSUE_TYPES):
                issue_type = self.ISSUE_TYPES[idx]
        
        # Use AI to match
        if not issue_type:
            prompt = f"""Match "{message}" ke salah satu:
{json.dumps(self.ISSUE_TYPES)}
JSON only: {{"matched_type": "tipe atau null", "confidence": "high/medium/low"}}"""
            
            try:
                resp = await client.chat.completions.create(
                    model=self.model,
                    messages=[{"role": "user", "content": prompt}],
                    temperature=0.2,
                    response_format={"type": "json_object"}
                )
                
                result = json.loads(resp.choices[0].message.content.strip())
                if result.get("matched_type") and result["confidence"] != "low":
                    issue_type = result["matched_type"]
            except Exception as e:
                print(f"Issue type error: {e}")
        
        if issue_type:
            collected_data["issue_type"] = issue_type
            
            instruction = f"""Jenis gangguan: {issue_type} âœ…

Task: Terakhir, minta ceritakan detail gangguannya (sejak kapan, sudah coba apa, dll). Max 2 kalimat."""
            
            reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
            next_state = self.STATE_COLLECT_DESCRIPTION
        else:
            issue_list = "\n".join([f"{i+1}. {t}" for i, t in enumerate(self.ISSUE_TYPES)])
            instruction = f"""Belum jelas jenis gangguannya.

Task: Minta pilih dari list ini:
{issue_list}

Balas nomor atau ketik jenis gangguannya. Max 2 kalimat."""
            
            reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
            next_state = self.STATE_COLLECT_ISSUE_TYPE
        
        return {
            "reply": reply,
            "session": {"state": next_state, "collected_data": collected_data}
        }
    
    async def _handle_description(
        self,
        customer_id: str,
        message: str,
        collected_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Collect description"""
        
        if len(message.strip()) < 5:
            instruction = "Deskripsi terlalu singkat. Minta detail lebih (sejak kapan, sudah coba apa). Max 2 kalimat."
            reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
            next_state = self.STATE_COLLECT_DESCRIPTION
        else:
            collected_data["description"] = message.strip()
            collected_data["timestamp"] = datetime.now().isoformat()
            
            # Generate summary
            summary = f"""ðŸ“‹ Nomor Pelanggan: {collected_data.get('customer_id', 'N/A')}
ðŸ‘¤ Nama: {collected_data.get('customer_name', 'N/A')}
ðŸ“ž Telepon: {collected_data.get('phone', 'N/A')}
ðŸ“ Alamat: {collected_data.get('address', 'N/A')}
âš ï¸ Jenis Gangguan: {collected_data.get('issue_type', 'N/A')}
ðŸ“ Deskripsi: {collected_data.get('description', 'N/A')}"""
            
            instruction = f"""Semua data sudah terkumpul. 

Show summary data:
{summary}

Task: Tanya apakah data sudah benar (balas: YA atau TIDAK). Max 3 kalimat total."""
            
            reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
            next_state = self.STATE_CONFIRM_DATA
        
        return {
            "reply": reply,
            "session": {"state": next_state, "collected_data": collected_data}
        }
    
    async def _handle_confirmation(
        self,
        customer_id: str,
        message: str,
        collected_data: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Handle confirmation"""
        
        msg_lower = message.lower().strip()
        
        if msg_lower in ["ya", "yes", "benar", "betul", "ok", "oke", "y", "yap", "yup"]:
            # Create ticket
            ticket_data = self._create_ticket(collected_data)
            
            instruction = f"""Laporan berhasil dibuat!

Nomor Laporan: #{ticket_data['ticket_id']}
Estimasi: {ticket_data['estimated_response']}

Task: Konfirmasi laporan berhasil dengan nomor laporan, bilang teknisi akan follow up, thank customer. Max 3 kalimat."""
            
            reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
            next_state = self.STATE_COMPLETED
            
            return {
                "reply": reply,
                "session": {"state": next_state, "collected_data": collected_data},
                "ticket_created": True,
                "ticket_data": ticket_data
            }
        
        elif msg_lower in ["tidak", "no", "salah", "belum", "n"]:
            instruction = "Data salah. Tanya bagian mana yang perlu diperbaiki atau ketik 'ulang' untuk mulai dari awal. Max 2 kalimat."
            reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
            next_state = self.STATE_GREETING
        
        else:
            instruction = "Belum jelas responnya. Tanya lagi: apakah data sudah benar? Balas YA atau TIDAK. Max 1 kalimat."
            reply = await self._generate_ai_response(customer_id, instruction, message, collected_data)
            next_state = self.STATE_CONFIRM_DATA
        
        return {
            "reply": reply,
            "session": {"state": next_state, "collected_data": collected_data}
        }
    
    def _create_ticket(self, collected_data: Dict[str, Any]) -> Dict[str, Any]:
        """Create ticket (mock for now)"""
        
        ticket_id = f"TKT{datetime.now().strftime('%Y%m%d')}{random.randint(1000, 9999)}"
        
        issue_type = collected_data.get("issue_type", "")
        if "mati total" in issue_type.lower():
            estimated = "2-4 jam"
            priority = "high"
        elif "lambat" in issue_type.lower():
            estimated = "4-6 jam"
            priority = "medium"
        else:
            estimated = "6-24 jam"
            priority = "low"
        
        ticket_data = {
            "ticket_id": ticket_id,
            "customer_id": collected_data.get("customer_id"),
            "customer_name": collected_data.get("customer_name"),
            "phone": collected_data.get("phone"),
            "address": collected_data.get("address"),
            "issue_type": collected_data.get("issue_type"),
            "description": collected_data.get("description"),
            "priority": priority,
            "estimated_response": estimated,
            "status": "open",
            "created_at": datetime.now().isoformat()
        }
        
        print(f"\n{'='*60}")
        print("ðŸŽ« TICKET CREATED")
        print(json.dumps(ticket_data, indent=2))
        print(f"{'='*60}\n")
        
        return ticket_data
